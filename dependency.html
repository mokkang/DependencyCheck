<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dependency Attack Path Visualizer ‚Äî Critical & High Only</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; color: #333; }
    .container { max-width: 1400px; margin: 0 auto; background: rgba(255,255,255,.95); border-radius: 20px; padding: 30px; box-shadow: 0 20px 40px rgba(0,0,0,.1); backdrop-filter: blur(10px); }
    h1 { text-align: center; color: #2c3e50; margin-bottom: 30px; font-size: 2.5em; background: linear-gradient(45deg, #3498db, #8e44ad); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .controls { display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; }
    .legend { display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; }
    .legend-item { display: flex; align-items: center; gap: 8px; padding: 8px 16px; background: rgba(255,255,255,.8); border-radius: 20px; border: 2px solid transparent; transition: all .3s ease; }
    .legend-item:hover { background: #fff; transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,.1); }
    .legend-circle { width: 16px; height: 16px; border-radius: 50%; border: 2px solid #fff; }
    .critical { background: #e74c3c; }
    .high { background: #f39c12; }
    .context { background: #95a5a6; }
    #graph-container { width: 100%; height: 600px; border: 3px solid #ddd; border-radius: 15px; overflow: hidden; background: radial-gradient(circle, #f8f9fa 0%, #e9ecef 100%); position: relative; }
    .info-panel { position: fixed; top: 50%; right: 20px; transform: translateY(-50%); width: 350px; max-height: 70vh; overflow-y: auto; background: rgba(255,255,255,.98); border: 3px solid #3498db; border-radius: 20px; padding: 25px; box-shadow: 0 20px 40px rgba(0,0,0,.15); backdrop-filter: blur(15px); display: none; z-index: 1000; }
    .info-panel h3 { margin-top: 0; color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
    .cve-item { background: linear-gradient(135deg, #fff5f5 0%, #ffeaea 100%); border: 2px solid #e74c3c; border-radius: 12px; padding: 15px; margin: 10px 0; transition: all .3s ease; }
    .cve-item:hover { transform: translateX(5px); box-shadow: 0 5px 15px rgba(231,76,60,.2); }
    .cve-id { font-weight: bold; color: #c0392b; font-size: 1.1em; }
    .cve-score { float: right; background: #e74c3c; color: #fff; padding: 4px 10px; border-radius: 20px; font-size: .9em; font-weight: bold; }
    .close-btn { position: absolute; top: 15px; right: 20px; background: #e74c3c; color: #fff; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 18px; transition: all .3s ease; }
    .close-btn:hover { background: #c0392b; transform: rotate(90deg); }
    .node { cursor: pointer; transition: all .3s ease; }
    .node:hover { filter: drop-shadow(0 0 10px rgba(0,0,0,.3)); }
    .link { stroke: #999; stroke-width: 2; cursor: pointer; transition: all .3s ease; }
    .link:hover { stroke: #3498db; stroke-width: 4; filter: drop-shadow(0 0 5px rgba(52,152,219,.5)); }
    .dependency-link { stroke: #3498db; stroke-width: 3; opacity: .8; }
    .attack-path { stroke: #e74c3c; stroke-width: 4; stroke-dasharray: 10,5; animation: dash 2s linear infinite; }
    @keyframes dash { to { stroke-dashoffset: -15; } }
    .node-label { font-size: 12px; font-weight: bold; text-anchor: middle; fill: #2c3e50; pointer-events: none; }
    button { background: linear-gradient(135deg, #3498db, #2980b9); color: #fff; border: none; padding: 12px 24px; border-radius: 25px; cursor: pointer; font-weight: bold; transition: all .3s ease; box-shadow: 0 5px 15px rgba(52,152,219,.3); }
    button:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(52,152,219,.4); }
    .tooltip { position: absolute; background: rgba(0,0,0,.9); color: #fff; padding: 10px; border-radius: 10px; pointer-events: none; font-size: 12px; max-width: 200px; z-index: 1000; opacity: 0; transition: opacity .3s ease; }
    .context-node { opacity: 0.55; }
  </style>
</head>
<body>
  <br />
  <div><a href="bnreplah.github.io/index.html" style="display:inline-block;padding:5px;margin:5px;border:1px solid white;z-index:0;position:absolute;">Home</a></div>
  <div class="container">
    <h1>üîç Dependency Attack Path Visualizer ‚Äî Critical & High Only</h1>

    <div class="controls">
      <div style="display:flex; align-items:center; gap:15px; margin-bottom:10px;">
        <label for="file-upload" style="cursor:pointer;background:linear-gradient(135deg,#27ae60,#2ecc71);color:white;padding:12px 24px;border-radius:25px;font-weight:bold;transition:all .3s ease;box-shadow:0 5px 15px rgba(46,204,113,.3);">üìÑ Upload SBOM/Manifest</label>
        <input type="file" id="file-upload" accept=".json,.yaml,.yml,.txt" style="display:none;" onchange="handleFileUpload(event)" />
        <span id="file-status" style="color:#27ae60;font-weight:bold;"></span>
      </div>
      <div style="display:flex; gap:15px; flex-wrap:wrap;">
        <button onclick="showAttackPaths()">üéØ Highlight Attack Paths</button>
        <button onclick="resetView()">üîÑ Reset View</button>
        <button onclick="centerGraph()">üìç Center Graph</button>
        <button onclick="loadSampleData()">üìä Load Sample Data</button>
      </div>
    </div>

    <div class="legend">
      <div class="legend-item"><div class="legend-circle critical"></div><span>Critical CVE (9.0+)</span></div>
      <div class="legend-item"><div class="legend-circle high"></div><span>High CVE (7.0‚Äì8.9)</span></div>
      <div class="legend-item"><div class="legend-circle context"></div><span>Context node (no known CVEs)</span></div>
    </div>

    <div id="graph-container"></div>
  </div>

  <div class="info-panel" id="info-panel">
    <button class="close-btn" onclick="closeInfoPanel()">√ó</button>
    <div id="info-content"></div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script>
    // ===== Sample data =====
    const sampleData = {
      nodes: [
        { id: "my-app", name: "My Application", version: "1.0.0", type: "root", cves: [] },
        { id: "express", name: "Express", version: "4.17.1", type: "direct", cves: [] },
        { id: "lodash", name: "Lodash", version: "4.17.19", type: "direct", cves: [ { id: "CVE-2021-23337", score: 7.2, description: "Prototype pollution vulnerability" } ] },
        { id: "moment", name: "Moment.js", version: "2.24.0", type: "transitive", cves: [ { id: "CVE-2022-31129", score: 7.5, description: "ReDoS vulnerability in moment parsing" } ] },
        { id: "axios", name: "Axios", version: "0.21.0", type: "direct", cves: [ { id: "CVE-2021-3749", score: 9.1, description: "Server-side request forgery vulnerability" } ] },
        { id: "yargs-parser", name: "Yargs Parser", version: "13.1.1", type: "transitive", cves: [ { id: "CVE-2020-7608", score: 5.3, description: "Prototype pollution vulnerability" } ] },
        { id: "minimist", name: "Minimist", version: "1.2.0", type: "transitive", cves: [ { id: "CVE-2021-44906", score: 9.8, description: "Prototype pollution leading to RCE" } ] },
        { id: "serialize-js", name: "Serialize JavaScript", version: "3.1.0", type: "transitive", cves: [] },
        { id: "handlebars", name: "Handlebars", version: "4.5.3", type: "transitive", cves: [ { id: "CVE-2021-23369", score: 8.1, description: "Remote code execution via template injection" } ] }
      ],
      links: [
        { source: "my-app", target: "express", relationship: "direct dependency" },
        { source: "my-app", target: "lodash", relationship: "direct dependency" },
        { source: "my-app", target: "axios", relationship: "direct dependency" },
        { source: "express", target: "moment", relationship: "transitive dependency" },
        { source: "express", target: "serialize-js", relationship: "transitive dependency" },
        { source: "lodash", target: "yargs-parser", relationship: "transitive dependency" },
        { source: "axios", target: "minimist", relationship: "transitive dependency" },
        { source: "moment", target: "handlebars", relationship: "transitive dependency" }
      ]
    };

    // ===== Graph state =====
    let nodes = sampleData.nodes; // will be replaced by filtered
    let links = sampleData.links; // will be replaced by filtered
    let svg, simulation, node, link, labels;

    // ===== Helpers =====
    const getSeverityColor = (cves) => {
      if (!cves || cves.length === 0) return "#95a5a6"; // context
      const maxScore = Math.max(...cves.map(c => c.score));
      if (maxScore >= 9.0) return "#e74c3c"; // critical
      if (maxScore >= 7.0) return "#f39c12"; // high
      return "#95a5a6"; // shouldn't appear after filtering, but treat as context
    };

    const getSeverityLabel = (score) => {
      if (score >= 9.0) return "Critical";
      if (score >= 7.0) return "High";
      return "Context";
    };

    function toId(v) { return (typeof v === 'object' && v !== null) ? v.id : v; }

    // Build a reverse adjacency map to find ancestors
    function buildReverseMap(edges) {
      const rev = new Map();
      edges.forEach(e => {
        const s = toId(e.source), t = toId(e.target);
        if (!rev.has(t)) rev.set(t, new Set());
        rev.get(t).add(s);
      });
      return rev;
    }

    function filterHighAndCritical() {
      const idToNode = new Map(nodes.map(n => [n.id, { ...n }]));
      const reverse = buildReverseMap(links);

      // 1) Start with nodes that have High/Critical CVEs
      const keep = new Set();
      const vuln = new Set();
      idToNode.forEach((n) => {
        const maxScore = (n.cves && n.cves.length) ? Math.max(...n.cves.map(c => c.score)) : 0;
        if (maxScore >= 7.0) { keep.add(n.id); vuln.add(n.id); }
      });

      // Always keep root if present
      const roots = [...idToNode.values()].filter(n => n.type === 'root');
      roots.forEach(r => keep.add(r.id));

      // 2) Add all ancestors (connectors) that lead to kept nodes (to preserve paths)
      const stack = [...keep];
      while (stack.length) {
        const cur = stack.pop();
        const parents = reverse.get(cur);
        if (!parents) continue;
        parents.forEach(p => {
          if (!keep.has(p)) { keep.add(p); stack.push(p); }
        });
      }

      // 3) Tag context nodes (kept but not vulnerable and not root)
      idToNode.forEach(n => {
        n._context = keep.has(n.id) && !vuln.has(n.id) && n.type !== 'root';
      });

      // 4) Create filtered lists
      const filteredNodes = [...idToNode.values()].filter(n => keep.has(n.id));
      const keepIds = new Set(filteredNodes.map(n => n.id));
      const filteredLinks = links.filter(e => keepIds.has(toId(e.source)) && keepIds.has(toId(e.target)));

      nodes = filteredNodes;
      links = filteredLinks;
    }

    // ===== Graph rendering =====
    function initGraph() {
      const container = d3.select('#graph-container');
      const width = container.node().getBoundingClientRect().width;
      const height = container.node().getBoundingClientRect().height;

      svg = container.append('svg').attr('width', width).attr('height', height);

      const zoom = d3.zoom().scaleExtent([0.1, 4]).on('zoom', (event) => {
        svg.selectAll('g').attr('transform', event.transform);
      });
      svg.call(zoom);

      const g = svg.append('g');

      simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(110))
        .force('charge', d3.forceManyBody().strength(-320))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(40));

      link = g.append('g')
        .selectAll('line')
        .data(links)
        .enter().append('line')
        .attr('class', d => d.isDependency ? 'link dependency-link' : 'link')
        .on('click', showLinkInfo)
        .on('mouseover', showTooltip)
        .on('mouseout', hideTooltip);

      node = g.append('g')
        .selectAll('circle')
        .data(nodes)
        .enter().append('circle')
        .attr('class', d => 'node' + (d._context ? ' context-node' : ''))
        .attr('r', d => d.type === 'root' ? 25 : 20)
        .attr('fill', d => getSeverityColor(d.cves))
        .attr('stroke', '#fff')
        .attr('stroke-width', 3)
        .on('click', showNodeInfo)
        .on('mouseover', showTooltip)
        .on('mouseout', hideTooltip)
        .call(d3.drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended));

      labels = g.append('g')
        .selectAll('text')
        .data(nodes)
        .enter().append('text')
        .attr('class', 'node-label')
        .attr('dy', 35)
        .text(d => d.name);

      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        node
          .attr('cx', d => d.x)
          .attr('cy', d => d.y);

        labels
          .attr('x', d => d.x)
          .attr('y', d => d.y);
      });
    }

    function showNodeInfo(event, d) {
      const panel = document.getElementById('info-panel');
      const content = document.getElementById('info-content');

      let html = `
        <h3>üì¶ ${d.name}</h3>
        <p><strong>Version:</strong> ${d.version}</p>
        <p><strong>Type:</strong> ${d.type}${d._context ? ' (context)' : ''}</p>
        ${d.bomRef ? `<p><strong>BOM Reference:</strong> ${d.bomRef}</p>` : ''}
        ${d.group ? `<p><strong>Group:</strong> ${d.group}</p>` : ''}
        ${d.scope ? `<p><strong>Scope:</strong> ${d.scope}</p>` : ''}
        ${d.publisher ? `<p><strong>Publisher:</strong> ${d.publisher}</p>` : ''}
        ${d.description ? `<p><strong>Description:</strong> ${d.description}</p>` : ''}
        <p><strong>CVEs Found:</strong> ${d.cves.length}</p>
      `;

      if (d.cves.length > 0) {
        html += '<h4>üö® Security Vulnerabilities:</h4>';
        d.cves.forEach(cve => {
          html += `
            <div class="cve-item" style="border-color: ${getSeverityColor([cve])};">
              <div class="cve-id">${cve.id}</div>
              <div class="cve-score" style="background: ${getSeverityColor([cve])};">${cve.score} (${cve.severity || getSeverityLabel(cve.score)})</div>
              <p><strong>Description:</strong> ${cve.description || '‚Äî'}</p>
              ${cve.published ? `<p><strong>Published:</strong> ${new Date(cve.published).toLocaleDateString()}</p>` : ''}
              ${cve.updated ? `<p><strong>Updated:</strong> ${new Date(cve.updated).toLocaleDateString()}</p>` : ''}
              ${cve.source && cve.source.name ? `<p><strong>Source:</strong> ${cve.source.name}</p>` : ''}
            </div>
          `;
        });
      } else if (d._context) {
        html += '<p style="color:#7f8c8d;">‚ÑπÔ∏è Context node kept to preserve the path to a vulnerable dependency.</p>';
      } else {
        html += '<p style="color:#27ae60;">‚úÖ No known vulnerabilities</p>';
      }

      // Relationships (using filtered links)
      const incomingDeps = links.filter(l => toId(l.target) === d.id);
      const outgoingDeps = links.filter(l => toId(l.source) === d.id);

      if (incomingDeps.length > 0) {
        html += '<h4>üì• Used By:</h4>';
        incomingDeps.forEach(dep => {
          const sourceNode = nodes.find(n => n.id === toId(dep.source));
          if (sourceNode) html += `<p>‚Ä¢ ${sourceNode.name} v${sourceNode.version}</p>`;
        });
      }

      if (outgoingDeps.length > 0) {
        html += '<h4>üì§ Dependencies:</h4>';
        outgoingDeps.forEach(dep => {
          const targetNode = nodes.find(n => n.id === toId(dep.target));
          if (targetNode) {
            const vulnCount = targetNode.cves ? targetNode.cves.length : 0;
            const vulnIndicator = vulnCount > 0 ? ` üö®(${vulnCount} CVEs)` : '';
            html += `<p>‚Ä¢ ${targetNode.name} v${targetNode.version}${vulnIndicator}${targetNode._context ? ' (context)' : ''}</p>`;
          }
        });
      }

      content.innerHTML = html;
      panel.style.display = 'block';
    }

    function showLinkInfo(event, d) {
      const panel = document.getElementById('info-panel');
      const content = document.getElementById('info-content');

      const sourceNode = nodes.find(n => n.id === toId(d.source));
      const targetNode = nodes.find(n => n.id === toId(d.target));

      let html = `
        <h3>üîó Dependency Relationship</h3>
        <p><strong>From:</strong> ${sourceNode.name} (${sourceNode.version})</p>
        <p><strong>To:</strong> ${targetNode.name} (${targetNode.version})</p>
        <p><strong>Relationship:</strong> ${d.relationship || 'dependency'}</p>
      `;

      if (targetNode.cves.length > 0) {
        html += `
          <div style="background:#fff3cd;border:2px solid #ffc107;border-radius:10px;padding:15px;margin:15px 0;">
            <h4>‚ö†Ô∏è Attack Path Identified</h4>
            <p>This dependency introduces <strong>${targetNode.cves.length}</strong> vulnerability(s):</p>
        `;
        targetNode.cves.forEach(cve => {
          html += `
            <div class="cve-item">
              <div class="cve-id">${cve.id}</div>
              <div class="cve-score">${cve.score}</div>
              <p>${cve.description || '‚Äî'}</p>
            </div>
          `;
        });
        html += '</div>';
      }

      content.innerHTML = html;
      panel.style.display = 'block';
    }

    function showAttackPaths() {
      // Highlight links that lead to vulnerable dependencies
      link.classed('attack-path', d => {
        const targetNode = nodes.find(n => n.id === toId(d.target));
        return targetNode.cves && targetNode.cves.length > 0;
      });

      // Pulse vulnerable nodes
      node.style('animation', d => (d.cves && d.cves.length > 0 ? 'pulse 2s infinite' : 'none'));

      // Add CSS for pulse animation
      const style = document.createElement('style');
      style.textContent = `@keyframes pulse { 0%{transform:scale(1)} 50%{transform:scale(1.1)} 100%{transform:scale(1)} }`;
      document.head.appendChild(style);
    }

    function resetView() {
      link.classed('attack-path', false);
      node.style('animation', 'none');
    }

    function centerGraph() {
      const svgEl = d3.select('#graph-container svg');
      const width = svgEl.node().getBoundingClientRect().width;
      const height = svgEl.node().getBoundingClientRect().height;
      svgEl.transition().duration(750).call(
        d3.zoom().transform,
        d3.zoomIdentity.translate(width / 2, height / 2).scale(1)
      );
    }

    function closeInfoPanel() { document.getElementById('info-panel').style.display = 'none'; }

    function showTooltip(event, d) {
      const tooltip = document.getElementById('tooltip');
      let content = '';
      if (d && d.name) {
        // Node tooltip
        const vulnCount = d.cves ? d.cves.length : 0;
        const vulnText = vulnCount > 0 ? ` | ${vulnCount} CVEs` : (d._context ? ' | context' : '');
        content = `${d.name} v${d.version}${vulnText}<br>Type: ${d.type}`;
        if (d.bomRef && d.bomRef !== d.name) content += `<br>Ref: ${d.bomRef}`;
      } else if (d && d.relationship) {
        // Link tooltip
        const linkType = d.isDependency ? ' (SBOM Dependency)' : '';
        content = `${d.relationship}${linkType}<br>Click for details`;
      }
      tooltip.innerHTML = content;
      tooltip.style.left = (event.pageX + 10) + 'px';
      tooltip.style.top = (event.pageY - 10) + 'px';
      tooltip.style.opacity = 1;
    }
    function hideTooltip() { document.getElementById('tooltip').style.opacity = 0; }

    function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
    function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
    function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }

    // ===== Lifecycle =====
    window.addEventListener('load', () => { loadSampleData(); });
    window.addEventListener('resize', () => { d3.select('#graph-container').select('svg').remove(); initGraph(); });

    function loadSampleData() {
      nodes = JSON.parse(JSON.stringify(sampleData.nodes));
      links = JSON.parse(JSON.stringify(sampleData.links));
      filterHighAndCritical();
      updateGraph();
      document.getElementById('file-status').textContent = 'Sample data loaded (Critical & High only)';
    }

    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const content = e.target.result;
          const parsedData = parseFileContent(content, file.name);
          if (parsedData) {
            nodes = parsedData.nodes;
            links = parsedData.links;
            filterHighAndCritical();
            updateGraph();
            document.getElementById('file-status').textContent = `‚úÖ ${file.name} loaded (Critical & High only)`;
          } else {
            document.getElementById('file-status').textContent = '‚ùå Unsupported or empty file';
          }
        } catch (error) {
          console.error('Error parsing file:', error);
          document.getElementById('file-status').textContent = '‚ùå Error parsing file';
        }
      };
      reader.readAsText(file);
    }

    function parseFileContent(content, filename) {
      const extension = filename.split('.').pop().toLowerCase();
      try {
        if (extension === 'json') return parseJSON(content);
        if (extension === 'txt') return parsePackageList(content);
        if (extension === 'yaml' || extension === 'yml') return parseYAML(content);
      } catch (error) {
        console.error('Parsing error:', error);
        return null;
      }
      return null;
    }

    function parseJSON(content) {
      const data = JSON.parse(content);
      if (data.bomFormat || data.specVersion) return parseCycloneDX(data); // CycloneDX JSON
      if (data.spdxVersion || data.SPDXID) return parseSPDX(data);        // SPDX JSON
      if (data.name && data.dependencies) return parsePackageLock(data);  // npm package-lock.json
      if (data.nodes && data.links) return data;                          // Already in graph format
      if (data.dependencies || data.devDependencies) return parsePackageJSON(data); // package.json
      return null;
    }

    function parseCycloneDX(data) {
      const nodes = []; const links = []; const nodeMap = new Map(); const vulnerabilityMap = new Map();

      if (data.vulnerabilities) {
        data.vulnerabilities.forEach(vuln => {
          if (vuln.affects && vuln.affects.length > 0) {
            vuln.affects.forEach(affect => {
              if (!affect.ref) return;
              if (!vulnerabilityMap.has(affect.ref)) vulnerabilityMap.set(affect.ref, []);
              let maxScore = 0; let severity = 'Unknown';
              if (vuln.ratings && vuln.ratings.length > 0) {
                vuln.ratings.forEach(rating => {
                  if (rating.score && rating.score > maxScore) { maxScore = rating.score; severity = rating.severity || 'Unknown'; }
                });
              }
              vulnerabilityMap.get(affect.ref).push({ id: vuln.id || 'Unknown CVE', score: maxScore, severity, description: vuln.description || vuln.detail || 'No description', source: vuln.source || {}, published: vuln.published, updated: vuln.updated });
            });
          }
        });
      }

      if (data.metadata && data.metadata.component) {
        const rc = data.metadata.component;
        const rootRef = rc['bom-ref'] || rc.name || 'root';
        const rootComponent = { id: rootRef, name: rc.name || 'Root Application', version: rc.version || '1.0.0', type: 'root', bomRef: rootRef, cves: vulnerabilityMap.get(rootRef) || [] };
        nodes.push(rootComponent); nodeMap.set(rootRef, rootComponent);
      }

      if (data.components) {
        data.components.forEach(component => {
          const bomRef = component['bom-ref'] || component.name || Math.random().toString(36).substr(2,9);
          const node = { id: bomRef, name: component.name || 'Unknown', version: component.version || 'unknown', type: component.type || 'library', bomRef, scope: component.scope || 'required', supplier: component.supplier || {}, publisher: component.publisher || '', group: component.group || '', description: component.description || '', cves: vulnerabilityMap.get(bomRef) || [] };
          nodes.push(node); nodeMap.set(bomRef, node);
        });
      }

      if (data.dependencies) {
        data.dependencies.forEach(dep => {
          const sourceRef = dep.ref; const sourceNode = nodeMap.get(sourceRef);
          if (sourceNode && dep.dependsOn && dep.dependsOn.length > 0) {
            dep.dependsOn.forEach(targetRef => {
              const targetNode = nodeMap.get(targetRef);
              if (!targetNode) return;
              let relType = (sourceNode.type === 'root' || sourceNode.type === 'application') ? 'direct dependency' : 'transitive dependency';
              links.push({ source: sourceRef, target: targetRef, relationship: relType, sourceComponent: sourceNode, targetComponent: targetNode, isDependency: true });
              if (sourceNode.type !== 'root' && targetNode.type !== 'root') targetNode.type = 'transitive';
            });
          }
        });
      }

      return { nodes, links };
    }

    function parseSPDX(data) {
      const nodes = []; const links = []; const nodeMap = new Map();
      if (data.name) { const root = { id: data.SPDXID || 'root', name: data.name, version: data.versionInfo || '1.0.0', type: 'root', cves: [] }; nodes.push(root); nodeMap.set(root.id, root); }
      if (data.packages) {
        data.packages.forEach(pkg => {
          const node = { id: pkg.SPDXID || pkg.name || Math.random().toString(36).substr(2,9), name: pkg.name || 'Unknown', version: pkg.versionInfo || 'unknown', type: 'direct', cves: [] };
          nodes.push(node); nodeMap.set(node.id, node);
        });
      }
      if (data.relationships) {
        data.relationships.forEach(rel => {
          if (rel.relationshipType === 'DEPENDS_ON' || rel.relationshipType === 'DEPENDENCY_OF') {
            const s = nodeMap.get(rel.spdxElementId); const t = nodeMap.get(rel.relatedSpdxElement);
            if (s && t) links.push({ source: s.id, target: t.id, relationship: rel.relationshipType.toLowerCase().replace('_', ' ') });
          }
        });
      }
      return { nodes, links };
    }

    function parsePackageLock(data) {
      const nodes = []; const links = []; const nodeMap = new Map();
      const root = { id: data.name || 'root', name: data.name || 'Root Application', version: data.version || '1.0.0', type: 'root', cves: [] };
      nodes.push(root); nodeMap.set(root.id, root);
      function processDependencies(deps, parentId, depth = 0) {
        if (!deps) return;
        Object.entries(deps).forEach(([name, info]) => {
          const nodeId = `${name}@${info.version || 'unknown'}`;
          if (!nodeMap.has(nodeId)) { const node = { id: nodeId, name, version: info.version || 'unknown', type: depth === 0 ? 'direct' : 'transitive', cves: [] }; nodes.push(node); nodeMap.set(nodeId, node); }
          if (parentId) links.push({ source: parentId, target: nodeId, relationship: depth === 0 ? 'direct dependency' : 'transitive dependency' });
          if (info.dependencies) processDependencies(info.dependencies, nodeId, depth + 1);
        });
      }
      processDependencies(data.dependencies, root.id);
      return { nodes, links };
    }

    function parsePackageJSON(data) {
      const nodes = []; const links = [];
      const root = { id: data.name || 'root', name: data.name || 'Root Application', version: data.version || '1.0.0', type: 'root', cves: [] };
      nodes.push(root);
      const allDeps = { ...(data.dependencies||{}), ...(data.devDependencies||{}), ...(data.peerDependencies||{}), ...(data.optionalDependencies||{}) };
      Object.entries(allDeps).forEach(([name, version]) => {
        const node = { id: `${name}@${version}`, name, version, type: 'direct', cves: [] };
        nodes.push(node); links.push({ source: root.id, target: node.id, relationship: 'direct dependency' });
      });
      return { nodes, links };
    }

    function parsePackageList(content) {
      const lines = content.split('\n').filter(line => line.trim());
      const nodes = []; const links = [];
      const root = { id: 'root', name: 'Root Application', version: '1.0.0', type: 'root', cves: [] };
      nodes.push(root);
      lines.forEach(line => {
        const trimmed = line.trim(); if (!trimmed) return;
        let name, version;
        if (trimmed.includes('@')) [name, version] = trimmed.split('@');
        else if (trimmed.includes('==')) [name, version] = trimmed.split('==');
        else if (trimmed.includes(' ')) [name, version] = trimmed.split(' ');
        else { name = trimmed; version = 'unknown'; }
        const node = { id: `${name}@${version}`, name, version, type: 'direct', cves: [] };
        nodes.push(node); links.push({ source: root.id, target: node.id, relationship: 'direct dependency' });
      });
      return { nodes, links };
    }

    function parseYAML(content) {
      try {
        const jsonContent = content
          .replace(/:\s*$/gm, ': null')
          .replace(/^(\s*)-\s+/gm, '$1"item": ')
          .replace(/^(\s*)([^":\s]+):\s*(.+)$/gm, '$1"$2": "$3"');
        return parseJSON(`{${jsonContent}}`);
      } catch (e) { console.error('YAML parsing error:', e); return null; }
    }

    function updateGraph() {
      d3.select('#graph-container').select('svg').remove();
      initGraph();
      const vulnCount = nodes.reduce((sum, n) => sum + (n.cves ? n.cves.length : 0), 0);
      const depLinks = links.length;
      console.log(`Graph updated: ${nodes.length} nodes, ${links.length} links (${depLinks} dependencies), ${vulnCount} total vulnerabilities`);
    }
  </script>
</body>
</html>
