<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Critical Dependency Attack Path Visualizer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <style>
    :root {
      --bg1: #667eea; --bg2: #764ba2; --ink: #2c3e50; --panel: rgba(255,255,255,0.95);
      --crit: #e74c3c; --high: #f39c12; --med: #f1c40f; --low: #2ecc71; --clean: #95a5a6;
      --pri: #3498db;
    }
    *{box-sizing:border-box}
    body{font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;margin:0;padding:20px;min-height:100vh;background:linear-gradient(135deg,var(--bg1) 0%,var(--bg2) 100%);color:#333}
    .container{max-width:1400px;margin:0 auto;background:var(--panel);border-radius:20px;padding:24px 24px 28px;box-shadow:0 20px 40px rgba(0,0,0,.1);backdrop-filter:blur(10px)}
    h1{margin:0 0 18px;text-align:center;font-size:2.2rem;color:var(--ink);background:linear-gradient(45deg,#3498db,#8e44ad);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .controls{display:flex;gap:16px;flex-wrap:wrap;align-items:center;margin-bottom:16px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    label.btn,input[type=file]{cursor:pointer}
    .btn{background:linear-gradient(135deg,#3498db,#2980b9);color:white;border:none;padding:10px 18px;border-radius:22px;font-weight:600;box-shadow:0 5px 15px rgba(52,152,219,.3);transition:.2s}
    .btn:hover{transform:translateY(-2px);box-shadow:0 8px 25px rgba(52,152,219,.45)}
    .btn-alt{background:linear-gradient(135deg,#27ae60,#2ecc71)}
    .btn-ghost{background:white;color:#2980b9;border:2px solid #2980b9}
    #graph-container{width:100%;height:620px;border:3px solid #ddd;border-radius:14px;overflow:hidden;background:radial-gradient(circle,#f8f9fa 0%,#e9ecef 100%);position:relative}
    .legend{display:flex;gap:12px;flex-wrap:wrap;margin:8px 0 16px}
    .legend-item{display:flex;align-items:center;gap:8px;padding:8px 12px;background:rgba(255,255,255,.9);border-radius:14px;border:2px solid transparent}
    .circle{width:14px;height:14px;border-radius:50%;border:2px solid #fff}
    .critical{background:var(--crit)}
    .info-panel{position:fixed;top:50%;right:20px;transform:translateY(-50%);width:360px;max-height:74vh;overflow:auto;background:rgba(255,255,255,.98);border:3px solid var(--pri);border-radius:18px;padding:18px 20px;box-shadow:0 20px 40px rgba(0,0,0,.15);display:none;z-index:10}
    .close-btn{position:absolute;right:12px;top:10px;background:var(--crit);color:#fff;border:none;width:28px;height:28px;border-radius:50%;cursor:pointer}
    .node{cursor:pointer;transition:.2s}
    .node:hover{filter:drop-shadow(0 0 10px rgba(0,0,0,.3))}
    .link{stroke:#999;stroke-width:2;cursor:pointer}
    .attack-path{stroke:var(--crit);stroke-width:4;stroke-dasharray:10 5;animation:dash 2s linear infinite}
    @keyframes dash{to{stroke-dashoffset:-15}}
    .node-label{font-size:12px;font-weight:700;text-anchor:middle;fill:var(--ink);pointer-events:none}
    .tooltip{position:absolute;background:rgba(0,0,0,.9);color:#fff;padding:10px;border-radius:10px;pointer-events:none;font-size:12px;max-width:220px;z-index:1000;opacity:0;transition:opacity .15s}
    .pill{display:inline-block;background:#eef6ff;border:1px solid #cfe3ff;border-radius:999px;padding:4px 9px;font-size:.8rem;color:#1f5ca8;margin:0 6px 6px 0}
    .field{display:flex;gap:8px;align-items:center}
    input[type=text],select{height:38px;border-radius:10px;border:2px solid #d7e6ff;padding:0 10px}
    .muted{opacity:.8}
    .small{font-size:.85rem}
    .panel{background:#fff;border:2px solid #e7eefc;padding:10px 12px;border-radius:12px}
    .result-step{padding:10px;border-left:4px solid var(--pri);background:#f8fbff;border-radius:8px;margin:8px 0}
  </style>
</head>
<body>
  <div class="container">
    <h1>üéØ Critical Dependency Attack Path Visualizer</h1>

    <div class="controls">
      <div class="row">
        <label for="file-upload" class="btn btn-alt">üìÑ Upload SBOM/Manifest</label>
        <input id="file-upload" type="file" accept=".json,.xml,.yaml,.yml,.txt" style="display:none" />
        <input id="project-name" type="text" placeholder="Project / Service name (e.g., msvc-orders)" />
        <button id="ingest-btn" class="btn">üì• Ingest & Save</button>
        <span id="file-status" class="pill muted"></span>
      </div>
      <div class="row">
        <button id="btn-attack" class="btn">‚ö° Highlight Critical Paths</button>
        <button id="btn-reset" class="btn btn-ghost">üîÑ Reset View</button>
        <button id="btn-center" class="btn btn-ghost">üìç Center Graph</button>
        <button id="btn-sample" class="btn btn-ghost">üìä Load Sample Data</button>
        <span class="pill">Showing: <strong>Critical (CVSS ‚â• 9.0)</strong> only</span>
      </div>
    </div>

    <div class="legend">
      <div class="legend-item"><div class="circle critical"></div><span>Critical CVE (9.0+)</span></div>
      <div class="legend-item"><span class="small muted">Nodes without critical findings are hidden from the graph but still stored in the DB.</span></div>
    </div>

    <div id="graph-container"></div>

    <div style="margin-top:16px" class="panel">
      <div class="row" style="gap:10px; align-items:flex-start; flex-wrap:wrap">
        <div class="field"><label>Source:</label><input id="path-src" type="text" placeholder="e.g., msvc-orders" /></div>
        <div class="field"><label>Target Library:</label><input id="path-dst" type="text" placeholder="e.g., tz (tz library)" /></div>
        <button id="btn-find" class="btn">üß≠ Find Path</button>
        <span class="small muted">Tip: Use component IDs or names stored in the DB for this project.</span>
      </div>
      <div id="path-result"></div>
    </div>
  </div>

  <div class="info-panel" id="info-panel">
    <button class="close-btn" id="close-info">√ó</button>
    <div id="info-content"></div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script>
    // ------------------------------
    // Minimal IndexedDB wrapper
    // ------------------------------
    const DB_NAME = 'sbomdb';
    const DB_VERSION = 1;

    function openDB(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onupgradeneeded = (e)=>{
          const db = e.target.result;
          if(!db.objectStoreNames.contains('projects')){
            const ps = db.createObjectStore('projects', { keyPath: 'id' });
          }
          if(!db.objectStoreNames.contains('components')){
            const cs = db.createObjectStore('components', { keyPath: ['projectId','id'] });
            cs.createIndex('byProject', 'projectId');
            cs.createIndex('byName', ['projectId','name']);
          }
          if(!db.objectStoreNames.contains('dependencies')){
            const ds = db.createObjectStore('dependencies', { keyPath: ['projectId','source','target'] });
            ds.createIndex('byProject', 'projectId');
          }
        };
        req.onsuccess = ()=>resolve(req.result);
        req.onerror = ()=>reject(req.error);
      });
    }

    async function tx(store, mode='readonly'){ const db = await openDB(); return db.transaction(store, mode).objectStore(store); }

    async function put(storeName, value){ const s = await tx(storeName, 'readwrite'); return new Promise((res,rej)=>{ const r=s.put(value); r.onsuccess=()=>res(true); r.onerror=()=>rej(r.error); }); }
    async function bulkPut(storeName, values){ const s = await tx(storeName, 'readwrite'); return Promise.all(values.map(v=>new Promise((res,rej)=>{ const r=s.put(v); r.onsuccess=()=>res(true); r.onerror=()=>rej(r.error); }))); }
    async function getAllByIndex(storeName, indexName, key){ const s = await tx(storeName); const idx = s.index(indexName); return new Promise((res,rej)=>{ const r=idx.getAll(key); r.onsuccess=()=>res(r.result||[]); r.onerror=()=>rej(r.error); }); }
    async function getAll(storeName){ const s = await tx(storeName); return new Promise((res,rej)=>{ const r=s.getAll(); r.onsuccess=()=>res(r.result||[]); r.onerror=()=>rej(r.error); }); }

    // ------------------------------
    // Graph state (keeps full graph; view filters to critical)
    // ------------------------------
    let fullNodes = []; // all nodes from latest load
    let fullLinks = [];
    let nodes = [];     // filtered for view (critical)
    let links = [];

    let svg, simulation, gRoot, nodeSel, linkSel, labelSel;

    const tooltipEl = document.getElementById('tooltip');
    const infoPanel = document.getElementById('info-panel');
    const infoContent = document.getElementById('info-content');

    const sampleData = {
      nodes: [
        { id: "msvc-orders", name: "msvc-orders", version: "2.1.0", type: "root", cves: [] },
        { id: "express@4.17.1", name: "express", version: "4.17.1", type: "direct", cves: [] },
        { id: "lodash@4.17.19", name: "lodash", version: "4.17.19", type: "direct", cves: [{ id:"CVE-2021-23337", score:7.2, description:"Prototype pollution" }] },
        { id: "tz@1.0.2", name: "tz", version: "1.0.2", type:"transitive", cves: [{ id:"CVE-2024-99999", score:9.8, description:"Arbitrary code execution in tz parser" }] },
        { id: "yargs-parser@13.1.1", name: "yargs-parser", version: "13.1.1", type: "transitive", cves: [{ id:"CVE-2020-7608", score:5.3, description:"Prototype pollution" }] },
        { id: "minimist@1.2.0", name: "minimist", version: "1.2.0", type: "transitive", cves: [{ id:"CVE-2021-44906", score:9.8, description:"RCE via prototype pollution" }] }
      ],
      links: [
        { source:"msvc-orders", target:"express@4.17.1", relationship:"direct dependency" },
        { source:"msvc-orders", target:"lodash@4.17.19", relationship:"direct dependency" },
        { source:"express@4.17.1", target:"tz@1.0.2", relationship:"transitive dependency" },
        { source:"lodash@4.17.19", target:"yargs-parser@13.1.1", relationship:"transitive dependency" },
        { source:"express@4.17.1", target:"minimist@1.2.0", relationship:"transitive dependency" }
      ]
    };

    // -------------- Helpers --------------
    function maxCVSS(node){ return (node.cves && node.cves.length) ? Math.max(...node.cves.map(c=>+c.score||0)) : 0; }
    function isCritical(node){ return maxCVSS(node) >= 9.0; }
    function severityColor(node){ return isCritical(node) ? getColor('--crit') : getColor('--clean'); }
    function getColor(v){ return getComputedStyle(document.documentElement).getPropertyValue(v) || '#95a5a6'; }

    function filterCriticalView(){
      const idSet = new Set();
      // Keep all critical nodes and any roots
      fullNodes.forEach(n=>{ if(n.type==='root' || isCritical(n)) idSet.add(n.id); });
      // Only include links whose endpoints are kept
      const filteredLinks = fullLinks.filter(l=> idSet.has(asId(l.source)) && idSet.has(asId(l.target)) );
      const filteredNodes = fullNodes.filter(n=> idSet.has(n.id));
      nodes = filteredNodes; links = filteredLinks;
    }

    function asId(x){ return (typeof x === 'string') ? x : (x.id || x.name); }

    // -------------- Graph --------------
    function initGraph(){
      const container = d3.select('#graph-container');
      const width = container.node().getBoundingClientRect().width;
      const height = container.node().getBoundingClientRect().height;

      svg = container.append('svg').attr('width', width).attr('height', height);
      const zoom = d3.zoom().scaleExtent([0.1, 4]).on('zoom', (ev)=>{ gRoot.attr('transform', ev.transform); });
      svg.call(zoom);
      gRoot = svg.append('g');

      simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d=>d.id).distance(120))
        .force('charge', d3.forceManyBody().strength(-320))
        .force('center', d3.forceCenter(width/2, height/2))
        .force('collision', d3.forceCollide().radius(42));

      linkSel = gRoot.append('g').selectAll('line').data(links).enter().append('line')
        .attr('class','link').on('click', (_,d)=>showLinkInfo(d)).on('mouseover', (ev,d)=>showTooltip(ev, `${d.relationship}`)).on('mouseout', hideTooltip);

      nodeSel = gRoot.append('g').selectAll('circle').data(nodes).enter().append('circle')
        .attr('class','node').attr('r', d=> d.type==='root'?26:20)
        .attr('fill', d=> severityColor(d)).attr('stroke','#fff').attr('stroke-width',3)
        .on('click', (_,d)=>showNodeInfo(d))
        .on('mouseover', (ev,d)=>{
          const cv = maxCVSS(d); const cves = d.cves?.length||0; showTooltip(ev, `${d.name} v${d.version}${cves?` ‚Ä¢ ${cves} CVEs (max ${cv})`:''}`);
        }).on('mouseout', hideTooltip)
        .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));

      labelSel = gRoot.append('g').selectAll('text').data(nodes).enter().append('text')
        .attr('class','node-label').attr('dy', 34).text(d=>d.name);

      simulation.on('tick', ()=>{
        linkSel.attr('x1', d=>d.source.x).attr('y1', d=>d.source.y).attr('x2', d=>d.target.x).attr('y2', d=>d.target.y);
        nodeSel.attr('cx', d=>d.x).attr('cy', d=>d.y);
        labelSel.attr('x', d=>d.x).attr('y', d=>d.y);
      });
    }

    function rebuild(){ d3.select('#graph-container').select('svg').remove(); filterCriticalView(); initGraph(); }

    function highlightCriticalPaths(){
      // any link whose target is critical
      linkSel.classed('attack-path', d=> isCritical(d.target));
      // pulse
      const style = document.createElement('style');
      style.textContent = `@keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.1)}100%{transform:scale(1)}}`;
      document.head.appendChild(style);
      nodeSel.style('animation', d=> isCritical(d) ? 'pulse 2s infinite' : 'none');
    }

    function resetView(){ if(!linkSel||!nodeSel) return; linkSel.classed('attack-path', false); nodeSel.style('animation','none'); }

    function centerGraph(){ const s = d3.select('#graph-container svg'); if(!s.node()) return; const w=s.node().getBoundingClientRect().width, h=s.node().getBoundingClientRect().height; s.transition().duration(600).call(d3.zoom().transform, d3.zoomIdentity.translate(w/2,h/2).scale(1)); }

    function showTooltip(ev, html){ tooltipEl.innerHTML = html; tooltipEl.style.left = (ev.pageX+10)+"px"; tooltipEl.style.top = (ev.pageY-10)+"px"; tooltipEl.style.opacity = 1; }
    function hideTooltip(){ tooltipEl.style.opacity = 0; }

    function showNodeInfo(d){
      let html = `<h3>üì¶ ${d.name}</h3>` +
                 `<p><strong>Version:</strong> ${d.version}</p>` +
                 `<p><strong>Type:</strong> ${d.type}</p>` +
                 `<p><strong>Critical CVEs:</strong> ${(d.cves||[]).filter(x=>+x.score>=9).length}</p>`;
      if(d.cves && d.cves.length){
        html += '<h4>üö® Vulnerabilities</h4>';
        d.cves.filter(x=>+x.score>=9).forEach(cve=>{
          html += `<div class="result-step"><strong>${cve.id}</strong> ‚Äî ${cve.score}<br/><span class="small">${cve.description||''}</span></div>`;
        });
      } else { html += '<p class="small muted">No CVEs recorded.</p>'; }
      infoContent.innerHTML = html; infoPanel.style.display='block';
    }

    function showLinkInfo(d){
      const src = d.source, tgt = d.target;
      let html = `<h3>üîó Dependency</h3><p><strong>From:</strong> ${src.name} (${src.version})<br/><strong>To:</strong> ${tgt.name} (${tgt.version})</p><p><strong>Relationship:</strong> ${d.relationship}</p>`;
      if(isCritical(tgt)){
        html += `<div class="result-step"><strong>‚ö†Ô∏è Attack Path:</strong> Target is critical. Updating <em>${tgt.name}</em> or replacing it will break this path.</div>`;
      }
      infoContent.innerHTML = html; infoPanel.style.display='block';
    }

    document.getElementById('close-info').onclick = ()=> infoPanel.style.display='none';

    // -------------- Parsing --------------
    function parseJSONGeneric(content){
      const data = JSON.parse(content);
      if (data.bomFormat || data.specVersion) return parseCycloneDX(data);
      if (data.spdxVersion || data.SPDXID)   return parseSPDX(data);
      if (data.name && data.dependencies)    return parsePackageLock(data);
      if (data.nodes && data.links)          return data;
      if (data.dependencies || data.devDependencies) return parsePackageJSON(data);
      return null;
    }

    function parseCycloneDX(data){
      const nodes=[], links=[], nodeMap=new Map(), vulnMap=new Map();
      if(data.vulnerabilities){
        data.vulnerabilities.forEach(v=>{
          (v.affects||[]).forEach(a=>{ if(!a.ref) return; if(!vulnMap.has(a.ref)) vulnMap.set(a.ref, []);
            let maxScore=0, sev='Unknown';
            (v.ratings||[]).forEach(r=>{ if(r.score && r.score>maxScore){ maxScore=r.score; sev=r.severity||sev; } });
            vulnMap.get(a.ref).push({ id: v.id||'Unknown CVE', score: maxScore, severity: sev, description: v.description||v.detail||'' });
          });
        });
      }
      let root=null;
      if(data.metadata && data.metadata.component){
        const c=data.metadata.component, ref=c['bom-ref']||c.name||'root';
        root={ id: ref, name: c.name||'Root', version:c.version||'1.0.0', type:'root', bomRef:ref, cves: vulnMap.get(ref)||[] };
        nodes.push(root); nodeMap.set(ref, root);
      }
      (data.components||[]).forEach(c=>{
        const ref=c['bom-ref']||c.name||Math.random().toString(36).slice(2);
        const n={ id: ref, name:c.name||'Unknown', version:c.version||'unknown', type:c.type||'library', bomRef:ref, scope:c.scope||'required', group:c.group||'', description:c.description||'', cves: vulnMap.get(ref)||[] };
        nodes.push(n); nodeMap.set(ref,n);
      });
      (data.dependencies||[]).forEach(d=>{
        const s=nodeMap.get(d.ref); if(!s) return; (d.dependsOn||[]).forEach(tRef=>{ const t=nodeMap.get(tRef); if(!t) return; links.push({ source:s.id, target:t.id, relationship: (s.type==='root'||s.type==='application')? 'direct dependency':'transitive dependency' }); });
      });
      return { nodes, links };
    }

    function parseSPDX(data){
      const nodes=[], links=[], map=new Map();
      if(data.name){ const root={ id:data.SPDXID||'root', name:data.name, version:data.versionInfo||'1.0.0', type:'root', cves:[] }; nodes.push(root); map.set(root.id,root); }
      (data.packages||[]).forEach(p=>{ const id=p.SPDXID||p.name||Math.random().toString(36).slice(2); const n={ id, name:p.name||'Unknown', version:p.versionInfo||'unknown', type:'direct', cves:[] }; nodes.push(n); map.set(id,n); });
      (data.relationships||[]).forEach(r=>{ if(r.relationshipType==='DEPENDS_ON'||r.relationshipType==='DEPENDENCY_OF'){ const s=map.get(r.spdxElementId), t=map.get(r.relatedSpdxElement); if(s&&t) links.push({ source:s.id, target:t.id, relationship:r.relationshipType.toLowerCase().replace('_',' ') }); } });
      return { nodes, links };
    }

    function parsePackageLock(data){
      const nodes=[], links=[], map=new Map();
      const root={ id:data.name||'root', name:data.name||'Root', version:data.version||'1.0.0', type:'root', cves:[] }; nodes.push(root); map.set(root.id, root);
      function walk(deps, parentId, depth=0){ if(!deps) return; Object.entries(deps).forEach(([name, info])=>{
        const id=`${name}@${info.version||'unknown'}`; if(!map.has(id)){ const n={ id, name, version:info.version||'unknown', type: depth===0?'direct':'transitive', cves: [] }; nodes.push(n); map.set(id,n); }
        links.push({ source: parentId, target: id, relationship: depth===0?'direct dependency':'transitive dependency' });
        if(info.dependencies) walk(info.dependencies, id, depth+1);
      }); }
      walk(data.dependencies, root.id, 0);
      return { nodes, links };
    }

    function parsePackageJSON(data){
      const nodes=[], links=[]; const root={ id:data.name||'root', name:data.name||'Root', version:data.version||'1.0.0', type:'root', cves:[] }; nodes.push(root);
      const all={ ...(data.dependencies||{}), ...(data.devDependencies||{}), ...(data.peerDependencies||{}), ...(data.optionalDependencies||{}) };
      Object.entries(all).forEach(([name, ver])=>{ const id=`${name}@${ver}`; nodes.push({ id, name, version:ver, type:'direct', cves:[] }); links.push({ source:root.id, target:id, relationship:'direct dependency' }); });
      return { nodes, links };
    }

    function parseTxtList(content){
      const lines = content.split('\n').map(x=>x.trim()).filter(Boolean);
      const nodes=[], links=[]; const root={ id:'root', name:'Root', version:'1.0.0', type:'root', cves:[] }; nodes.push(root);
      for(const line of lines){ let name, version='unknown'; if(line.includes('@')){ [name, version] = line.split('@'); } else if(line.includes('==')){ [name, version] = line.split('=='); } else if(line.includes(' ')){ [name, version] = line.split(' '); } else { name=line; }
        const id=`${name}@${version}`; nodes.push({ id, name, version, type:'direct', cves:[] }); links.push({ source:root.id, target:id, relationship:'direct dependency' }); }
      return { nodes, links };
    }

    async function handleFile(file){
      const text = await file.text(); const ext = (file.name.split('.').pop()||'').toLowerCase();
      if(ext==='json') return parseJSONGeneric(text);
      if(ext==='xml')  { console.warn('XML parsing not implemented in this trimmed build. Provide CycloneDX JSON for best results.'); return null; }
      if(ext==='yaml'||ext==='yml'){ console.warn('YAML parsing not implemented in this trimmed build.'); return null; }
      if(ext==='txt')  return parseTxtList(text);
      return null;
    }

    // -------------- Persistence (Ingest) --------------
    async function ingestToDB(projectId, data){
      if(!projectId) throw new Error('Project name is required');
      await put('projects', { id: projectId, updatedAt: Date.now() });
      const comps = data.nodes.map(n=>({ projectId, id:n.id, name:n.name, version:n.version, type:n.type, cves:n.cves||[] }));
      const deps  = data.links.map(l=>({ projectId, source: asId(l.source), target: asId(l.target), relationship:l.relationship||'dependency' }));
      await bulkPut('components', comps); await bulkPut('dependencies', deps);
    }

    // -------------- Path Finding --------------
    async function getGraphForProject(projectId){
      const comps = await getAllByIndex('components','byProject', projectId);
      const deps  = await getAllByIndex('dependencies','byProject', projectId);
      const map = new Map(comps.map(c=>[c.id,c]));
      // Build adjacency
      const adj = new Map();
      deps.forEach(d=>{ if(!adj.has(d.source)) adj.set(d.source, []); adj.get(d.source).push(d.target); });
      return { comps, deps, map, adj };
    }

    function bfsPath(adj, start, goal){
      const q=[[start]]; const seen=new Set([start]);
      while(q.length){ const path=q.shift(); const last=path[path.length-1]; if(last===goal) return path; const ns=adj.get(last)||[]; for(const n of ns){ if(!seen.has(n)){ seen.add(n); q.push([...path,n]); } }
      }
      return null;
    }

    function fixAdvice(path){
      // The direct depender of the target is the last predecessor
      if(!path || path.length < 2) return null;
      const target = path[path.length-1];
      const directOwner = path[path.length-2];
      return { target, directOwner };
    }

    function renderPathSummary(projectId, path, map){
      const el = document.getElementById('path-result');
      if(!path){ el.innerHTML = '<p class="small muted">No path found.</p>'; return; }
      const steps = path.map(id=> map.get(id) || {id,name:id,version:'?'});
      const advice = fixAdvice(path);
      el.innerHTML = `
        <div class="result-step"><strong>Project:</strong> ${projectId}</div>
        ${steps.map((s,i)=>`<div class="result-step">${i===0?'Source':'‚Üí'} <strong>${s.name||s.id}</strong> <span class="muted">v${s.version||''}</span></div>`).join('')}
        <div class="result-step">üéØ <strong>Direct owner to fix:</strong> <code>${advice.directOwner}</code><br/><span class="small">Bump/replace dependency where <code>${advice.directOwner}</code> lists <code>${advice.target}</code> directly.</span></div>
      `;
    }

    // -------------- UI Wiring --------------
    document.getElementById('btn-sample').onclick = async ()=>{
      fullNodes = [...sampleData.nodes]; fullLinks = [...sampleData.links]; rebuild();
      document.getElementById('file-status').textContent = 'Sample loaded';
    };

    document.getElementById('btn-attack').onclick = ()=> highlightCriticalPaths();
    document.getElementById('btn-reset').onclick  = ()=> resetView();
    document.getElementById('btn-center').onclick = ()=> centerGraph();

    document.getElementById('file-upload').addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if(!f) return; const parsed = await handleFile(f);
      if(!parsed){ document.getElementById('file-status').textContent = '‚ùå Unsupported or unparsed file'; return; }
      fullNodes = parsed.nodes; fullLinks = parsed.links; rebuild();
      document.getElementById('file-status').textContent = `‚úÖ ${f.name} parsed`;
    });

    document.getElementById('ingest-btn').onclick = async ()=>{
      const project = (document.getElementById('project-name').value||'').trim();
      if(!project){ alert('Enter a Project / Service name'); return; }
      if(!fullNodes.length){ alert('Load SBOM or sample first'); return; }
      try{ await ingestToDB(project, {nodes: fullNodes, links: fullLinks}); document.getElementById('file-status').textContent = `üíæ Saved to DB for project "${project}"`; }
      catch(err){ console.error(err); alert('Failed to save: '+err.message); }
    };

    document.getElementById('btn-find').onclick = async ()=>{
      const project = (document.getElementById('project-name').value||'').trim();
      const src = (document.getElementById('path-src').value||'').trim();
      const dst = (document.getElementById('path-dst').value||'').trim();
      if(!project || !src || !dst){ alert('Provide Project name, Source, and Target Library'); return; }
      const { adj, map } = await getGraphForProject(project);
      const path = bfsPath(adj, src, dst);
      renderPathSummary(project, path, map);
    };

    // first paint: sample for convenience
    fullNodes = [...sampleData.nodes]; fullLinks = [...sampleData.links]; rebuild();

    // --- DnD helpers
    function dragstarted(event,d){ if(!event.active) simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; }
    function dragged(event,d){ d.fx=event.x; d.fy=event.y; }
    function dragended(event,d){ if(!event.active) simulation.alphaTarget(0); d.fx=null; d.fy=null; }
  </script>
</body>
</html>
